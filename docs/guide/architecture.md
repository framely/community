# Under the Hood

Framely consists of platform and runtime. Platform is the place where builder define, share conversational components and packaging these components into enjoyable conversational services. The artifacts defined on the platform is then generated into Kotlin code where it can be deployed along with Framely runtime to any environment where java runs. 

## Platform

Platform is the place where builder first declaratively define conversational components, then find, share and reuse these component via packaging them into conversational services. To define component, builder can first  


## Runtime
Assume the services is already available through APIs. To make chatbot fulfill customers' needs, at same time to reach our business goal, we need to program or codify three different modules. 

### Dialog Understanding
Dialog understanding based on natural language understanding (NLU). We need to understand what the users tell us, regardless if it is service payload, i.e., "I want two tickets for star wars at 7:00", or it is some dialogue act, i.e. "That is alright. But thanks.". By understanding, we really mean that we can normalize seemingly infinite number of equivalent expressions into some structured form where we can execute some symbolic operation on top. The example for such normalized frame event is "buy(amount=2, movie=star wars, time=7:00pm)". Notice the understanding is already context dependent, the same customer utterance can potentially be converted into different frame events, under different dialog expectations.

### Dialog Management
Dialog manager by state machine. The chatbot needs to take normalized user input, based on current state of interaction, generates a response and updates the state at the same time. State machine is natural fit for this reactive logic, and its behavior can be easily modified by transition and emission or interaction rules. We added support for functions, which allow dialog manager to naturally interact with the business logic/data via APIs or database connections.

### Response Generation
Once we have something to say, represented by the structured information generated by the execution of functions, we can template it into script with a style that not only delivers the content, but also promotes users collaboration and satisfaction. And best of all, this scripting work can be handled by a conversational user experience team. This is place that we can also easy switch to different languages.


## Services and Application Logics



